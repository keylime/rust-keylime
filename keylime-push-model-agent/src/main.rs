// SPDX-License-Identifier: Apache-2.0
// Copyright 2025 Keylime Authors
use crate::struct_filler::StructureFiller;
use anyhow::{Context, Result};
use clap::Parser;
use log::{debug, error, info};
use std::{
    fs::{self, File},
    io::Read,
    time::Duration,
};
mod struct_filler;

const DEFAULT_TIMEOUT_MILLIS: &str = "5000";
const HTTPS_PREFIX: &str = "https://";
const DEFAULT_API_VERSION: &str = "v3.0";
const DEFAULT_INDEX: &str = "1";
const DEFAULT_METHOD: &str = "POST";

pub struct ResponseInformation {
    pub status_code: reqwest::StatusCode,
    pub body: String,
}

fn get_api_version(args: &Args) -> String {
    if args.api_version.is_some() {
        return args.api_version.clone().unwrap();
    }
    DEFAULT_API_VERSION.to_string()
}

fn get_index(args: &Args) -> String {
    if args.index.is_some() {
        return args.index.clone().unwrap();
    }
    DEFAULT_INDEX.to_string()
}

fn get_index_suffix(args: &Args) -> String {
    let index = get_index(args);
    if args.method.is_some() && args.method.as_ref().unwrap() == "PATCH" {
        return format!("/{index}");
    }
    "".to_string()
}

fn get_attestation_request_url(args: &Args) -> String {
    let id = args.identifier.clone();
    let verifier_url = args.verifier_url.clone();
    let api_version = get_api_version(args);
    let index_suffix = get_index_suffix(args);
    if verifier_url.ends_with('/') {
        return format!(
            "{verifier_url}{api_version}/agents/{id}/attestations{index_suffix}"
        );
    }
    format!(
        "{verifier_url}/{api_version}/agents/{id}/attestations{index_suffix}"
    )
}

fn get_https_client(args: &Args) -> Result<reqwest::Client> {
    let mut builder = reqwest::Client::builder()
        .connection_verbose(true)
        .timeout(Duration::from_millis(args.timeout));

    if args.insecure.unwrap_or(false) {
        builder = builder.danger_accept_invalid_certs(true);
    } else {
        // Get CA certificate from file
        let mut buf = Vec::new();
        File::open(args.ca_certificate.clone())
            .context(format!(
                "Failed to open '{}' file",
                args.ca_certificate
            ))?
            .read_to_end(&mut buf)
            .context(format!(
                "Failed to read '{}' to the end",
                args.ca_certificate
            ))?;
        let ca_cert =
            reqwest::Certificate::from_pem(&buf).context(format!(
                "Failed to parse certificate from PEM file '{}'",
                args.ca_certificate
            ))?;

        // Get client key and certificate from files
        let cert = fs::read(args.certificate.clone()).context(format!(
            "Failed to read client certificate from file '{}'",
            args.certificate
        ))?;
        let key = fs::read(args.key.clone()).context(format!(
            "Failed to read key from file '{}'",
            args.key
        ))?;
        let identity = reqwest::Identity::from_pkcs8_pem(&cert, &key)
            .context(format!(
            "Failed to add client identity from certificate '{}' and key '{}'",
            args.certificate,
            args.key
        ))?;

        builder = builder
            .add_root_certificate(ca_cert)
            .identity(identity)
            // Here we disable hostname verification because the certificates generated by the
            // verifier don't have the Subject Alternative Name (SAN) properly set, failing
            // hostname verification
            .danger_accept_invalid_hostnames(true)
    }
    builder.build().context("Failed to create HTTPS client")
}

fn get_client(args: &Args) -> Result<reqwest::Client> {
    if args.verifier_url.starts_with(HTTPS_PREFIX) {
        return get_https_client(args);
    }
    reqwest::Client::builder()
        .timeout(Duration::from_millis(args.timeout))
        .build()
        .context("Failed to build plain HTTP client")
}

fn get_attestation_filler_request(args: &Args) -> Box<dyn StructureFiller> {
    if args.json_file.is_none() {
        return Box::new(struct_filler::AttestationRequestFillerFromCode {});
    }
    Box::new(struct_filler::AttestationRequestFillerFromFile {
        file_path: args.json_file.clone().unwrap(),
    })
}

fn get_request_builder_from_method(
    args: &Args,
) -> Result<reqwest::RequestBuilder> {
    let client = get_client(args)?;
    match args.method.as_deref() {
        Some("POST") => {
            Ok(client.post(get_attestation_request_url(args).as_str()))
        }
        Some("PUT") => {
            Ok(client.put(get_attestation_request_url(args).as_str()))
        }
        Some("DELETE") => {
            Ok(client.delete(get_attestation_request_url(args).as_str()))
        }
        Some("GET") => {
            Ok(client.get(get_attestation_request_url(args).as_str()))
        }
        Some("PATCH") => {
            Ok(client.patch(get_attestation_request_url(args).as_str()))
        }
        _ => Ok(client.post(get_attestation_request_url(args).as_str())),
    }
}

async fn send_attestation_request(
    args: &Args,
) -> Result<ResponseInformation> {
    let filler = get_attestation_filler_request(args);
    let request = filler.get_attestation_request();
    let serialized = serde_json::to_string(&request)
        .expect("failed to serialize request as JSON");
    debug!("Serialized Request: {}", serialized);

    let reqb = get_request_builder_from_method(args)?;

    let response = reqb
        .json(&request)
        .timeout(Duration::from_millis(args.timeout))
        .send()
        .await?;
    let sc = response.status();
    info!("Response code:{}", response.status());
    info!("Response headers: {:?}", response.headers());
    let response_body = response.text().await?;
    if !response_body.is_empty() {
        info!("Response body: {}", response_body);
    }
    let rsp = ResponseInformation {
        status_code: sc,
        body: response_body,
    };
    Ok(rsp)
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None, ignore_errors = true)]
struct Args {
    /// API version
    /// Default: "v3.0"
    #[arg(long, default_value = DEFAULT_API_VERSION)]
    api_version: Option<String>,
    /// CA certificate file
    #[arg(long, default_value = "/var/lib/keylime/cv_ca/cacert.crt")]
    ca_certificate: String,
    /// Client certificate file
    #[arg(
        short,
        long,
        default_value = "/var/lib/keylime/cv_ca/client-cert.crt"
    )]
    certificate: String,
    /// Client private key file
    #[arg(
        short,
        long,
        default_value = "/var/lib/keylime/cv_ca/client-private.pem"
    )]
    key: String,
    /// json file
    #[arg(short, long, default_missing_value = "")]
    json_file: Option<String>,
    /// identifier
    /// Default: 12345678
    #[arg(long, default_value = "12345678")]
    identifier: String,
    /// index
    /// Default: 1
    #[arg(long, default_value = "1")]
    index: Option<String>,
    /// insecure
    #[arg(long, action, default_missing_value = "true")]
    insecure: Option<bool>,
    /// Method
    /// Default: "POST"
    #[arg(long, default_value = DEFAULT_METHOD)]
    method: Option<String>,
    /// Timeout in milliseconds
    /// Default: 5000
    #[arg(long, default_value = DEFAULT_TIMEOUT_MILLIS)]
    timeout: u64,
    /// Verifier URL
    #[arg(short, long, default_value = "https://127.0.0.1:8881")]
    verifier_url: String,
}

async fn run() -> Result<()> {
    let args = Args::parse();
    info!("API version: {}", get_api_version(&args));
    info!("Verifier URL: {}", args.verifier_url);
    debug!("Timeout: {}", args.timeout);
    debug!("CA certificate file: {}", args.ca_certificate);
    debug!("Identifier: {}", args.identifier);
    debug!("Index: {}", get_index(&args));
    debug!(
        "Method: {}",
        args.method.clone().unwrap_or(DEFAULT_METHOD.to_string())
    );
    debug!("Certificate file: {}", args.certificate);
    debug!("Key file: {}", args.key);
    debug!("Insecure: {}", args.insecure.unwrap_or(false));
    let res = send_attestation_request(&args).await;
    match res {
        Ok(_) => {
            info!("Request sent successfully");
            info!(
                "Returned response code: {:?}",
                res.as_ref().unwrap().status_code
            );
            info!("Returned response body: {:?}", res.as_ref().unwrap().body);
        }
        Err(ref e) => error!("Error: {}", e),
    }
    Ok(())
}

#[actix_web::main]
async fn main() -> Result<()> {
    pretty_env_logger::init();
    run().await
}

#[cfg(test)]
mod tests {
    use super::*;
    const TEST_TIMEOUT_MILLIS: u64 = 100;

    #[actix_rt::test]
    async fn get_index_test() {
        let index = get_index(&Args {
            api_version: None,
            verifier_url: "https://1.2.3.4:5678/".to_string(),
            timeout: TEST_TIMEOUT_MILLIS,
            ca_certificate: "/tmp/does_not_exist.pem".to_string(),
            certificate: "/tmp/does_not_exist.pem".to_string(),
            key: "/tmp/does_not_exist.pem".to_string(),
            insecure: Some(false),
            identifier: "024680".to_string(),
            json_file: None,
            method: None,
            index: Some("2".to_string()),
        });
        assert_eq!(index, "2".to_string());
    } // get_attestation_request_url_test

    #[actix_rt::test]
    async fn send_attestation_request_test() {
        if (send_attestation_request(&Args {
            api_version: Some("v3.0".to_string()),
            verifier_url: "http://1.2.3.4:5678".to_string(),
            timeout: TEST_TIMEOUT_MILLIS,
            ca_certificate: "/tmp/does_not_exist.pem".to_string(),
            certificate: "/tmp/does_not_exist.pem".to_string(),
            key: "/tmp/does_not_exist.pem".to_string(),
            insecure: Some(false),
            identifier: "12345678".to_string(),
            json_file: None,
            method: None,
            index: None,
        })
        .await)
            .is_ok()
        {
            unreachable!()
        }
    }

    #[actix_rt::test]
    async fn send_attestation_request_test_no_cert_file() {
        match send_attestation_request(&Args {
            api_version: Some("v3.0".to_string()),
            verifier_url: "https://1.2.3.4:5678".to_string(),
            timeout: TEST_TIMEOUT_MILLIS,
            ca_certificate: "/tmp/unexisting_cert_file".to_string(),
            certificate: "/tmp/unexisting_cert_file".to_string(),
            key: "/tmp/unexisting_key_file".to_string(),
            insecure: Some(false),
            identifier: "12345678".to_string(),
            json_file: None,
            method: None,
            index: None,
        })
        .await
        {
            Ok(_) => unreachable!(),
            Err(e) => {
                assert!(
                    e.to_string().contains(
                        "Failed to open '/tmp/unexisting_cert_file' file"
                    ),
                    "Unexpected error"
                )
            }
        }
    }

    #[actix_rt::test]
    async fn send_attestation_request_test_on_https() {
        let temp_workdir = tempfile::tempdir().unwrap(); //#[allow_ci]
        let ca_cert_file_path = temp_workdir.path().join("test_ca_cert_file");
        let _ca_cert_file = File::create(&ca_cert_file_path)
            .expect("Failed to create CA cert file");
        let cert_file_path = temp_workdir.path().join("test_cert_file");
        let _cert_file = File::create(&cert_file_path)
            .expect("Failed to create cert file");
        let key_file_path = temp_workdir.path().join("test_key_file");
        let _key_file =
            File::create(&key_file_path).expect("Failed to create key file");

        match send_attestation_request(&Args {
            api_version: Some("3.0".to_string()),
            verifier_url: "https://1.2.3.4:5678/".to_string(),
            timeout: TEST_TIMEOUT_MILLIS,
            ca_certificate: ca_cert_file_path.display().to_string(),
            certificate: cert_file_path.display().to_string(),
            key: key_file_path.display().to_string(),
            insecure: Some(false),
            identifier: "12345678".to_string(),
            json_file: None,
            method: None,
            index: None,
        })
        .await
        {
            Ok(_) => unreachable!(),
            Err(e) => {
                assert_eq!(
                    e.to_string(),
                    format!(
                        "Failed to parse certificate from PEM file '{}'",
                        ca_cert_file_path.display()
                    )
                )
            }
        }
        match send_attestation_request(&Args {
            api_version: Some("3.0".to_string()),
            verifier_url: "https://1.2.3.4:5678/".to_string(),
            timeout: TEST_TIMEOUT_MILLIS,
            ca_certificate: ca_cert_file_path.display().to_string(),
            certificate: cert_file_path.display().to_string(),
            key: key_file_path.display().to_string(),
            insecure: Some(true),
            identifier: "12345678".to_string(),
            index: None,
            json_file: None,
            method: None,
        })
        .await
        {
            Ok(_) => unreachable!(),
            Err(e) => {
                assert!(e
                    .to_string()
                    .contains("error sending request for url (https://1.2.3.4:5678/3.0/agents/12345678/attestations)"))
            }
        }
        match send_attestation_request(&Args {
            api_version: Some("3.0".to_string()),
            verifier_url: "https://1.2.3.4:5678/".to_string(),
            timeout: TEST_TIMEOUT_MILLIS,
            ca_certificate: ca_cert_file_path.display().to_string(),
            certificate: cert_file_path.display().to_string(),
            key: key_file_path.display().to_string(),
            insecure: Some(true),
            identifier: "12345678".to_string(),
            json_file: Some(
                "./tests/evidence_supported_attestation_request.json"
                    .to_string(),
            ),
            method: None,
            index: None,
        })
        .await
        {
            Ok(_) => unreachable!(),
            Err(e) => {
                assert!(e
                    .to_string()
                    .contains("error sending request for url (https://1.2.3.4:5678/3.0/agents/12345678/attestations)"))
            }
        }
    }

    #[actix_rt::test]
    async fn different_methods_test() {
        // array with the different methods:
        let methods = vec!["DELETE", "GET", "POST", "PUT", "PATCH"];
        for method in methods {
            match send_attestation_request(&Args {
                api_version: None,
                verifier_url: "http://1.2.3.4:5678".to_string(),
                timeout: TEST_TIMEOUT_MILLIS,
                ca_certificate: "/tmp/does_not_exists.pem".to_string(),
                certificate: "/tmp/does_not_exists.pem".to_string(),
                key: "/tmp/does_not_exists.pem".to_string(),
                insecure: Some(false),
                identifier: "12345678".to_string(),
                json_file: None,
                method: Some(method.to_string()),
                index: None,
            })
            .await
            {
                Ok(_) => unreachable!(),
                Err(e) => {
                    assert!(e.to_string().contains("error sending request for url (http://1.2.3.4:5678/v3.0/agents/12345678/attestations)") ||
                    e.to_string().contains("error sending request for url (http://1.2.3.4:5678/v3.0/agents/12345678/attestations/1)"));
                }
            }
        }
    }

    #[actix_rt::test]
    async fn get_attestation_request_url_test() {
        let url = get_attestation_request_url(&Args {
            api_version: None,
            verifier_url: "https://1.2.3.4:5678/".to_string(),
            timeout: TEST_TIMEOUT_MILLIS,
            ca_certificate: "/tmp/does_not_exists.pem".to_string(),
            certificate: "/tmp/does_not_exists.pem".to_string(),
            key: "/tmp/does_not_exists.pem".to_string(),
            insecure: Some(false),
            identifier: "024680".to_string(),
            json_file: None,
            method: Some("PATCH".to_string()),
            index: Some("2".to_string()),
        });
        assert_eq!(
            url,
            "https://1.2.3.4:5678/v3.0/agents/024680/attestations/2"
        );
    } // get_attestation_request_url_test

    #[actix_rt::test]
    async fn mockoon_based_test() {
        if std::env::var("MOCKOON").is_ok() {
            match send_attestation_request(&Args {
                api_version: None,
                verifier_url: "http://localhost:3000".to_string(),
                timeout: TEST_TIMEOUT_MILLIS,
                ca_certificate: "/tmp/does_not_exist.pem".to_string(),
                certificate: "/tmp/does_not_exist.pem".to_string(),
                key: "/tmp/does_not_exist.pem".to_string(),
                insecure: Some(false),
                identifier: "12345678".to_string(),
                json_file: None,
                method: Some("POST".to_string()),
                index: None,
            })
            .await
            {
                Ok(r) => {
                    assert!(r.status_code == reqwest::StatusCode::OK);
                }
                Err(_) => {
                    unreachable!()
                }
            }
            match send_attestation_request(&Args {
                api_version: Some("-1.2.3".to_string()),
                verifier_url: "http://localhost:3000".to_string(),
                timeout: TEST_TIMEOUT_MILLIS,
                ca_certificate: "/tmp/does_not_exist.pem".to_string(),
                certificate: "/tmp/does_not_exist.pem".to_string(),
                key: "/tmp/does_not_exist.pem".to_string(),
                insecure: Some(false),
                identifier: "12345678".to_string(),
                json_file: None,
                method: Some("POST".to_string()),
                index: None,
            })
            .await
            {
                Ok(r) => {
                    assert!(r.status_code == reqwest::StatusCode::NOT_FOUND);
                }
                Err(_) => {
                    unreachable!()
                }
            }
        }
    } // mockoon_based_test

    #[actix_rt::test]
    async fn run_test() {
        let res = run();
        assert!(res.await.is_ok());
    }
}
