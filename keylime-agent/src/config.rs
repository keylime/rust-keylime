// SPDX-License-Identifier: Apache-2.0
// Copyright 2022 Keylime Authors

use crate::{api::SUPPORTED_API_VERSIONS, permissions, tpm};
use config::{
    builder::DefaultState, Config, ConfigBuilder, ConfigError, Environment,
    File, FileFormat, Map, Source, Value, ValueKind::Table,
};
use glob::glob;
use keylime::{
    algorithms::{EncryptionAlgorithm, HashAlgorithm, SignAlgorithm},
    hostname_parser::{parse_hostname, HostnameParsingError},
    ip_parser::{parse_ip, IpParsingError},
    list_parser::{parse_list, ListParsingError},
    version::{self, GetErrorInput},
};
use log::*;
use serde::{Deserialize, Serialize, Serializer};
use serde_json::Value as JsonValue;
use std::{
    collections::HashMap,
    env,
    path::{Path, PathBuf},
    str::FromStr,
};
use thiserror::Error;
use uuid::Uuid;

pub static CONFIG_VERSION: &str = "2.0";
pub static DEFAULT_API_VERSIONS: &str = "default";
pub static DEFAULT_UUID: &str = "d432fbb3-d2f1-4a97-9ef7-75bd81c00000";
pub static DEFAULT_IP: &str = "127.0.0.1";
pub static DEFAULT_PORT: u32 = 9002;
pub static DEFAULT_CONTACT_IP: &str = "127.0.0.1";
pub static DEFAULT_CONTACT_PORT: u32 = 9002;
pub static DEFAULT_REGISTRAR_IP: &str = "127.0.0.1";
pub static DEFAULT_REGISTRAR_PORT: u32 = 8890;
pub static DEFAULT_ENABLE_AGENT_MTLS: bool = true;
pub static DEFAULT_KEYLIME_DIR: &str = "/var/lib/keylime";
pub static DEFAULT_SERVER_KEY: &str = "server-private.pem";
pub static DEFAULT_SERVER_CERT: &str = "server-cert.crt";
pub static DEFAULT_IAK_CERT: &str = "iak-cert.crt";
pub static DEFAULT_IDEVID_CERT: &str = "idevid-cert.crt";
pub static DEFAULT_SERVER_KEY_PASSWORD: &str = "";
// The DEFAULT_TRUSTED_CLIENT_CA is relative from KEYLIME_DIR
pub static DEFAULT_TRUSTED_CLIENT_CA: &str = "cv_ca/cacert.crt";
pub static DEFAULT_ENC_KEYNAME: &str = "derived_tci_key";
pub static DEFAULT_DEC_PAYLOAD_FILE: &str = "decrypted_payload";
pub static DEFAULT_SECURE_SIZE: &str = "1m";
pub static DEFAULT_TPM_OWNERPASSWORD: &str = "";
pub static DEFAULT_EXTRACT_PAYLOAD_ZIP: bool = true;
pub static DEFAULT_ENABLE_REVOCATION_NOTIFICATIONS: bool = false;
pub static DEFAULT_REVOCATION_ACTIONS_DIR: &str = "/usr/libexec/keylime";
pub static DEFAULT_REVOCATION_NOTIFICATION_IP: &str = "127.0.0.1";
pub static DEFAULT_REVOCATION_NOTIFICATION_PORT: u32 = 8992;
// Note: The revocation certificate name is generated inside the Python tenant and the
// certificate(s) can be generated by running the tenant with the --cert flag. For more
// information, check the README: https://github.com/keylime/keylime/#using-keylime-ca
pub static DEFAULT_REVOCATION_CERT: &str = "RevocationNotifier-cert.crt";
pub static DEFAULT_REVOCATION_ACTIONS: &str = "";
pub static DEFAULT_PAYLOAD_SCRIPT: &str = "autorun.sh";
pub static DEFAULT_ENABLE_INSECURE_PAYLOAD: bool = false;
pub static DEFAULT_ALLOW_PAYLOAD_REVOCATION_ACTIONS: bool = true;
pub static DEFAULT_TPM_HASH_ALG: &str = "sha256";
pub static DEFAULT_TPM_ENCRYPTION_ALG: &str = "rsa";
pub static DEFAULT_TPM_SIGNING_ALG: &str = "rsassa";
pub static DEFAULT_EK_HANDLE: &str = "generate";
pub static DEFAULT_ENABLE_IAK_IDEVID: bool = false;
pub static DEFAULT_IAK_IDEVID_ASYMMETRIC_ALG: &str = "rsa";
pub static DEFAULT_IAK_IDEVID_NAME_ALG: &str = "sha256";
pub static DEFAULT_IAK_IDEVID_TEMPLATE: &str = "H-1";
pub static DEFAULT_IDEVID_PASSWORD: &str = "";
pub static DEFAULT_IAK_PASSWORD: &str = "";
pub static DEFAULT_IDEVID_HANDLE: &str = "";
pub static DEFAULT_IAK_HANDLE: &str = "";
pub static DEFAULT_RUN_AS: &str = "keylime:tss";
pub static DEFAULT_AGENT_DATA_PATH: &str = "agent_data.json";
pub static DEFAULT_IMA_ML_PATH: &str =
    "/sys/kernel/security/ima/ascii_runtime_measurements";
pub static DEFAULT_MEASUREDBOOT_ML_PATH: &str =
    "/sys/kernel/security/tpm0/binary_bios_measurements";
pub static DEFAULT_CONFIG: &str = "/etc/keylime/agent.conf";
pub static DEFAULT_CONFIG_SYS: &str = "/usr/etc/keylime/agent.conf";

#[derive(Error, Debug)]
pub enum KeylimeConfigError {
    // Error from config crate
    #[error("Error from the config crate")]
    Config(#[from] ConfigError),

    // Generic configuration error
    #[error("Configuration error: {0}")]
    Generic(String),

    // Glob error
    #[error("Glob pattern error")]
    GlobPattern(#[from] glob::PatternError),

    // Host name parsing error
    #[error("Host name parsing error")]
    HostnameParsing(#[from] HostnameParsingError),

    // Incompatible options error
    #[error("Incompatible configuration options '{option_a}' set as '{value_a}', but '{option_b}' is set as '{value_b}'")]
    IncompatibleOptions {
        option_a: String,
        value_a: String,
        option_b: String,
        value_b: String,
    },

    // Infallible
    #[error("Infallible")]
    Infallible(#[from] std::convert::Infallible),

    // IP parsing error
    #[error("IP parsing error")]
    IpParsing(#[from] IpParsingError),

    // Unsupported type in configuration
    #[error(
        "Unsupported type conversion from serde_json::Value to config::Value"
    )]
    JsonConversion,

    // List parsing error
    #[error("List parsing error")]
    ListParsing(#[from] ListParsingError),

    // Missing configuration file set in KEYLIME_AGENT_CONFIG
    #[error("Missing file {file} set in 'KEYLIME_AGENT_CONFIG' environment variable")]
    MissingEnvConfigFile { file: String },

    // Missing directory set in keylime_dir configuration option
    #[error(
        "Missing directory {path} set in 'keylime_dir' configuration option"
    )]
    MissingKeylimeDir {
        path: String,
        source: std::io::Error,
    },

    #[error("Required option {0} not set in configuration")]
    RequiredOption(String),

    // Error from serde crate
    #[error("Serde error")]
    Serde(#[from] serde_json::Error),
}

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub(crate) struct AgentConfig {
    pub agent_data_path: String,
    pub allow_payload_revocation_actions: bool,
    pub api_versions: String,
    pub contact_ip: String,
    pub contact_port: u32,
    pub dec_payload_file: String,
    pub ek_handle: String,
    pub enable_agent_mtls: bool,
    pub enable_iak_idevid: bool,
    pub enable_insecure_payload: bool,
    pub enable_revocation_notifications: bool,
    pub enc_keyname: String,
    pub extract_payload_zip: bool,
    pub iak_cert: String,
    pub iak_handle: String,
    pub iak_idevid_asymmetric_alg: String,
    pub iak_idevid_name_alg: String,
    pub iak_idevid_template: String,
    pub iak_password: String,
    pub idevid_cert: String,
    pub idevid_handle: String,
    pub idevid_password: String,
    pub ima_ml_path: String,
    pub ip: String,
    pub keylime_dir: String,
    pub measuredboot_ml_path: String,
    pub payload_script: String,
    pub port: u32,
    pub registrar_ip: String,
    pub registrar_port: u32,
    pub revocation_actions: String,
    pub revocation_actions_dir: String,
    pub revocation_cert: String,
    pub revocation_notification_ip: String,
    pub revocation_notification_port: u32,
    pub run_as: String,
    pub secure_size: String,
    pub server_cert: String,
    pub server_key: String,
    pub server_key_password: String,
    pub tpm_encryption_alg: String,
    pub tpm_hash_alg: String,
    pub tpm_ownerpassword: String,
    pub tpm_signing_alg: String,
    pub trusted_client_ca: String,
    pub uuid: String,
    pub version: String,
}

#[derive(Clone, Debug)]
struct EnvConfig {
    map: HashMap<String, Value>,
}

impl EnvConfig {
    pub fn new() -> Result<Self, KeylimeConfigError> {
        let env_source = Environment::with_prefix("KEYLIME_AGENT")
            .separator(".")
            .prefix_separator("_");

        // Log debug message for configuration obtained from environment
        env_source
            .collect()?
            .iter()
            .for_each(|(c, v)| debug!("Environment configuration {c}={v}"));

        // Return an EnvConfig containing the collected environment variables in a format that
        // allows it to be used as a Source for KeylimeConfig
        Ok(EnvConfig {
            map: Map::from([(
                "agent".to_string(),
                Value::from(env_source.collect()?),
            )]),
        })
    }
}

impl Source for EnvConfig {
    fn collect(&self) -> Result<Map<String, Value>, ConfigError> {
        Ok(self.map.clone())
    }

    fn clone_into_box(&self) -> Box<dyn Source + Send + Sync> {
        Box::new(self.clone())
    }
}

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub(crate) struct KeylimeConfig {
    pub agent: AgentConfig,
}

impl KeylimeConfig {
    pub fn new() -> Result<Self, KeylimeConfigError> {
        // Get the base configuration file from the environment variable or the default locations
        let config: KeylimeConfig =
            config_get_setting()?.build()?.try_deserialize()?;

        // Replace keywords with actual values
        config_translate_keywords(&config)
    }
}

// Helper function to convert serde_json::Value to config::Value
fn json_to_config_value(json_value: JsonValue) -> Result<Value, ConfigError> {
    match json_value {
        JsonValue::Bool(b) => Ok(Value::from(b)),
        JsonValue::Number(n) => {
            if let Some(i) = n.as_i64() {
                Ok(Value::from(i))
            } else if let Some(u) = n.as_u64() {
                Ok(Value::from(u))
            } else if let Some(f) = n.as_f64() {
                Ok(Value::from(f))
            } else {
                Err(ConfigError::Foreign(Box::new(
                    KeylimeConfigError::JsonConversion,
                )))
            }
        }
        JsonValue::String(s) => Ok(Value::from(s)),
        JsonValue::Array(arr) => Ok(Value::from(
            arr.into_iter()
                .map(json_to_config_value)
                .collect::<Result<Vec<_>, ConfigError>>()?,
        )),
        JsonValue::Object(obj) => {
            let mut m = Map::new();
            for (k, v) in obj.into_iter() {
                _ = m.insert(k, json_to_config_value(v)?)
            }
            Ok(Value::from(m))
        }
        JsonValue::Null => Err(ConfigError::Foreign(Box::new(
            KeylimeConfigError::JsonConversion,
        ))),
    }
}

impl Source for AgentConfig {
    fn collect(&self) -> Result<Map<String, Value>, ConfigError> {
        let json = serde_json::to_value(self)
            .map_err(|e| ConfigError::Foreign(Box::new(e)))?;

        let config_map = json_to_config_value(json)?.into_table()?;

        Ok(Map::from([("agent".to_string(), Value::from(config_map))]))
    }

    fn clone_into_box(&self) -> Box<dyn Source + Send + Sync> {
        Box::new(self.clone())
    }
}

impl Source for KeylimeConfig {
    fn collect(&self) -> Result<Map<String, Value>, ConfigError> {
        self.agent.collect()
    }

    fn clone_into_box(&self) -> Box<dyn Source + Send + Sync> {
        Box::new(self.clone())
    }
}

impl Default for AgentConfig {
    fn default() -> Self {
        // In case the process is executed by privileged user
        let run_as = if permissions::get_euid() == 0 {
            DEFAULT_RUN_AS.to_string()
        } else {
            "".to_string()
        };

        AgentConfig {
            agent_data_path: "default".to_string(),
            allow_payload_revocation_actions:
                DEFAULT_ALLOW_PAYLOAD_REVOCATION_ACTIONS,
            api_versions: DEFAULT_API_VERSIONS.to_string(),
            contact_ip: DEFAULT_CONTACT_IP.to_string(),
            contact_port: DEFAULT_CONTACT_PORT,
            dec_payload_file: DEFAULT_DEC_PAYLOAD_FILE.to_string(),
            ek_handle: DEFAULT_EK_HANDLE.to_string(),
            enable_agent_mtls: DEFAULT_ENABLE_AGENT_MTLS,
            enable_iak_idevid: DEFAULT_ENABLE_IAK_IDEVID,
            enable_insecure_payload: DEFAULT_ENABLE_INSECURE_PAYLOAD,
            enable_revocation_notifications:
                DEFAULT_ENABLE_REVOCATION_NOTIFICATIONS,
            enc_keyname: DEFAULT_ENC_KEYNAME.to_string(),
            extract_payload_zip: DEFAULT_EXTRACT_PAYLOAD_ZIP,
            iak_cert: "default".to_string(),
            iak_handle: DEFAULT_IAK_HANDLE.to_string(),
            iak_idevid_asymmetric_alg: DEFAULT_IAK_IDEVID_ASYMMETRIC_ALG
                .to_string(),
            iak_idevid_name_alg: DEFAULT_IAK_IDEVID_NAME_ALG.to_string(),
            iak_idevid_template: DEFAULT_IAK_IDEVID_TEMPLATE.to_string(),
            iak_password: DEFAULT_IAK_PASSWORD.to_string(),
            idevid_cert: "default".to_string(),
            idevid_handle: DEFAULT_IDEVID_HANDLE.to_string(),
            idevid_password: DEFAULT_IDEVID_PASSWORD.to_string(),
            ima_ml_path: "default".to_string(),
            ip: DEFAULT_IP.to_string(),
            keylime_dir: DEFAULT_KEYLIME_DIR.to_string(),
            measuredboot_ml_path: "default".to_string(),
            payload_script: DEFAULT_PAYLOAD_SCRIPT.to_string(),
            port: DEFAULT_PORT,
            registrar_ip: DEFAULT_REGISTRAR_IP.to_string(),
            registrar_port: DEFAULT_REGISTRAR_PORT,
            revocation_actions: DEFAULT_REVOCATION_ACTIONS.to_string(),
            revocation_actions_dir: DEFAULT_REVOCATION_ACTIONS_DIR
                .to_string(),
            revocation_cert: "default".to_string(),
            revocation_notification_ip: DEFAULT_REVOCATION_NOTIFICATION_IP
                .to_string(),
            revocation_notification_port:
                DEFAULT_REVOCATION_NOTIFICATION_PORT,
            run_as,
            secure_size: DEFAULT_SECURE_SIZE.to_string(),
            server_cert: "default".to_string(),
            server_key: "default".to_string(),
            server_key_password: DEFAULT_SERVER_KEY_PASSWORD.to_string(),
            tpm_encryption_alg: DEFAULT_TPM_ENCRYPTION_ALG.to_string(),
            tpm_hash_alg: DEFAULT_TPM_HASH_ALG.to_string(),
            tpm_ownerpassword: DEFAULT_TPM_OWNERPASSWORD.to_string(),
            tpm_signing_alg: DEFAULT_TPM_SIGNING_ALG.to_string(),
            trusted_client_ca: "default".to_string(),
            uuid: DEFAULT_UUID.to_string(),
            version: CONFIG_VERSION.to_string(),
        }
    }
}

impl Default for KeylimeConfig {
    fn default() -> Self {
        let c = KeylimeConfig {
            agent: AgentConfig::default(),
        };

        // The default config should never fail to translate keywords
        config_translate_keywords(&c).unwrap() //#[allow_ci]
    }
}

fn config_get_setting(
) -> Result<ConfigBuilder<DefaultState>, KeylimeConfigError> {
    let default_config = KeylimeConfig::default();
    let mut builder = Config::builder()
        // Default values
        .add_source(default_config);

    // If the 'KEYLIME_AGENT_CONFIG' environment variable is set, load the configuration file set
    // and ignore system configurations
    if let Ok(env_cfg) = env::var("KEYLIME_AGENT_CONFIG") {
        if !env_cfg.is_empty() {
            let path = Path::new(&env_cfg);
            if (path.exists()) {
                builder = builder.add_source(
                    File::new(&env_cfg, FileFormat::Toml).required(true),
                )
            } else {
                warn!("Configuration set in KEYLIME_AGENT_CONFIG environment variable not found");
                return Err(KeylimeConfigError::MissingEnvConfigFile {
                    file: path.display().to_string(),
                });
            }
        }
    } else {
        // Load the system configuration files.
        builder = builder
            // Add the system configuration file
            .add_source(
                File::new(DEFAULT_CONFIG_SYS, FileFormat::Toml)
                    .required(false),
            )
            // Add system configuration snippets
            .add_source(
                glob("/usr/etc/keylime/agent.conf.d/*")
                    .map_err(KeylimeConfigError::GlobPattern)?
                    .filter_map(|entry| entry.ok())
                    .map(|path| {
                        File::new(
                            &path.display().to_string(),
                            FileFormat::Toml,
                        )
                        .required(false)
                    })
                    .collect::<Vec<_>>(),
            )
            // Add user configuration file
            .add_source(
                File::new(DEFAULT_CONFIG, FileFormat::Toml).required(false),
            )
            // Add user configuration snippets
            .add_source(
                glob("/etc/keylime/agent.conf.d/*")
                    .map_err(KeylimeConfigError::GlobPattern)?
                    .filter_map(|entry| entry.ok())
                    .map(|path| {
                        File::new(
                            &path.display().to_string(),
                            FileFormat::Toml,
                        )
                        .required(false)
                    })
                    .collect::<Vec<_>>(),
            );
    }

    let env_config = EnvConfig::new()?;

    builder = builder
        // Add environment variables overrides
        .add_source(env_config);

    Ok(builder)
}

/// Replace the options that support keywords with the final value
fn config_translate_keywords(
    config: &KeylimeConfig,
) -> Result<KeylimeConfig, KeylimeConfigError> {
    let uuid = get_uuid(&config.agent.uuid);

    let env_keylime_dir = env::var("KEYLIME_DIR").ok();
    let keylime_dir = match env_keylime_dir {
        Some(ref dir) => {
            if dir.is_empty() {
                match &config.agent.keylime_dir {
                    s => Path::new(s),
                    _ => Path::new(DEFAULT_KEYLIME_DIR),
                }
            } else {
                Path::new(dir)
            }
        }
        None => match &config.agent.keylime_dir {
            s => Path::new(s),
            _ => Path::new(DEFAULT_KEYLIME_DIR),
        },
    };

    // Validate that keylime_dir exists
    #[cfg(not(test))]
    let keylime_dir = &keylime_dir.canonicalize().map_err(|e| {
        KeylimeConfigError::MissingKeylimeDir {
            path: keylime_dir.display().to_string(),
            source: e,
        }
    })?;

    let root_path = Path::new("/");

    let mut agent_data_path = config_get_file_path(
        "agent_data_path",
        &config.agent.agent_data_path,
        keylime_dir,
        DEFAULT_AGENT_DATA_PATH,
        false,
    );

    let mut ima_ml_path = config_get_file_path(
        "ima_ml_path",
        &config.agent.ima_ml_path,
        root_path,
        DEFAULT_IMA_ML_PATH,
        false,
    );

    let mut measuredboot_ml_path = config_get_file_path(
        "measuredboot_ml_path",
        &config.agent.measuredboot_ml_path,
        root_path,
        DEFAULT_MEASUREDBOOT_ML_PATH,
        false,
    );

    let mut server_key = config_get_file_path(
        "server_key",
        &config.agent.server_key,
        keylime_dir,
        DEFAULT_SERVER_KEY,
        false,
    );

    let mut server_cert = config_get_file_path(
        "server_cert",
        &config.agent.server_cert,
        keylime_dir,
        DEFAULT_SERVER_CERT,
        false,
    );

    let trusted_client_ca: String =
        parse_list(&config.agent.trusted_client_ca)?
            .iter()
            .map(|t| {
                config_get_file_path(
                    "trusted_client_ca",
                    t,
                    keylime_dir,
                    DEFAULT_TRUSTED_CLIENT_CA,
                    false,
                )
            })
            .collect::<Vec<_>>()
            .join(", ");

    let mut iak_cert = config_get_file_path(
        "iak_cert",
        &config.agent.iak_cert,
        keylime_dir,
        DEFAULT_IAK_CERT,
        true,
    );

    let mut idevid_cert = config_get_file_path(
        "idevid_cert",
        &config.agent.idevid_cert,
        keylime_dir,
        DEFAULT_IDEVID_CERT,
        true,
    );

    let ek_handle = match config.agent.ek_handle.as_ref() {
        "generate" => "".to_string(),
        "" => "".to_string(),
        s => s.to_string(),
    };

    let ip = match parse_ip(config.agent.ip.as_ref()) {
        Ok(ip) => ip.to_string(),
        Err(_) => {
            debug!("Parsing configured IP as hostname");
            parse_hostname(config.agent.ip.as_ref())?.to_string()
        }
    };

    let contact_ip = match parse_ip(config.agent.contact_ip.as_ref()) {
        Ok(ip) => ip.to_string(),
        Err(_) => {
            debug!("Parsing configured contact IP as hostname");
            parse_hostname(config.agent.contact_ip.as_ref())?.to_string()
        }
    };

    let registrar_ip = match parse_ip(config.agent.registrar_ip.as_ref()) {
        Ok(ip) => ip.to_string(),
        Err(_) => {
            debug!("Parsing configured registrar IP as hostname");
            parse_hostname(config.agent.registrar_ip.as_ref())?.to_string()
        }
    };

    // Parse the configured API versions and check against the list of supported versions
    // In case none of the configured API versions are supported, fallback to use all the supported
    // versions
    // If the "default" keyword is used, use all the supported versions
    // If the "latest" keyword is used, use only the latest version
    let api_versions: String = match config.agent.api_versions.as_ref() {
        "default" => SUPPORTED_API_VERSIONS
            .iter()
            .map(|&s| s.to_string())
            .collect::<Vec<String>>()
            .join(", "),
        "latest" => {
            if let Some(version) =
                SUPPORTED_API_VERSIONS.iter().map(|&s| s.to_string()).last()
            {
                version
            } else {
                unreachable!();
            }
        }
        versions => {
            let parsed: Vec<String> = match parse_list(
                &config.agent.api_versions,
            ) {
                Ok(list) => {
                    let mut filtered_versions = list
                    .iter()
                    .inspect(|e| { if !SUPPORTED_API_VERSIONS.contains(e) {
                        warn!("Skipping API version \"{e}\" obtained from 'api_versions' configuration option")
                    }})
                    .filter(|e| SUPPORTED_API_VERSIONS.contains(e))
                    .map(|&s| version::Version::from_str(s))
                    .inspect(|err| if let Err(e) = err {
                        warn!("Skipping API version \"{}\" obtained from 'api_versions' configuration option", e.input());
                    })
                    .filter(|e| e.is_ok())
                    .map(|v| {
                        let Ok(ver) = v else {unreachable!();};
                        ver
                    })
                    .collect::<Vec<version::Version>>();

                    // Sort the versions from the configuration from the oldest to the newest
                    filtered_versions.sort();
                    filtered_versions
                        .iter()
                        .map(|v| v.to_string())
                        .collect::<Vec<String>>()
                }
                Err(e) => {
                    warn!("Failed to parse list from 'api_versions' configuration option; using default supported versions");
                    SUPPORTED_API_VERSIONS.iter().map(|&s| s.into()).collect()
                }
            };

            if parsed.is_empty() {
                warn!("No supported version found in 'api_versions' configuration option; using default supported versions");
                SUPPORTED_API_VERSIONS
                    .iter()
                    .map(|&s| s.to_string())
                    .collect::<Vec<String>>()
                    .join(", ")
            } else {
                parsed.join(", ")
            }
        }
    };

    // Validate the configuration

    // If revocation notifications is enabled, verify all the required options for revocation
    if config.agent.enable_revocation_notifications {
        if config.agent.revocation_notification_ip.is_empty() {
            error!("The option 'enable_revocation_notifications' is set as 'true' but 'revocation_notification_ip' was set as empty");
            return Err(KeylimeConfigError::IncompatibleOptions {
                option_a: "enable_revocation_notifications".into(),
                value_a: "true".into(),
                option_b: "revocation_notification_ip".into(),
                value_b: "empty".into(),
            });
        }
        if config.agent.revocation_cert.is_empty() {
            error!("The option 'enable_revocation_notifications' is set as 'true' 'revocation_cert' was set as empty");
            return Err(KeylimeConfigError::IncompatibleOptions {
                option_a: "enable_revocation_notifications".into(),
                value_a: "true".into(),
                option_b: "revocation_notification_cert".into(),
                value_b: "empty".into(),
            });
        }
        let actions_dir = match config.agent.revocation_actions_dir.as_ref() {
            "" => {
                error!("The option 'enable_revocation_notifications' is set as 'true' but the revocation actions directory was set as empty in 'revocation_actions_dir'");
                return Err(KeylimeConfigError::IncompatibleOptions {
                    option_a: "enable_revocation_notifications".into(),
                    value_a: "true".into(),
                    option_b: "revocation_actions_dir".into(),
                    value_b: "empty".into(),
                });
            }
            dir => dir.to_string(),
        };
    }

    let mut revocation_cert = config_get_file_path(
        "revocation_cert",
        &config.agent.revocation_cert,
        keylime_dir,
        &format!("secure/unzipped/{DEFAULT_REVOCATION_CERT}"),
        false,
    );

    Ok(KeylimeConfig {
        agent: AgentConfig {
            agent_data_path,
            api_versions,
            contact_ip,
            ek_handle,
            iak_cert,
            idevid_cert,
            ima_ml_path,
            ip,
            keylime_dir: keylime_dir.display().to_string(),
            measuredboot_ml_path,
            registrar_ip,
            revocation_cert,
            server_cert,
            server_key,
            trusted_client_ca,
            uuid,
            ..config.agent.clone()
        },
    })
}

/// Expand a file path from the configuration file.
///
/// If the string is set as "default", return the provided default path relative from the provided work_dir.
/// If the string is empty, use the default value unless the 'leave_empty' is 'true'
/// If the string is a relative path, return the path relative from the provided work_dir
/// If the string is an absolute path, return the path without change.
fn config_get_file_path(
    option: &str,
    path: &str,
    work_dir: &Path,
    default: &str,
    leave_empty: bool,
) -> String {
    match path {
        "default" => work_dir.join(default).display().to_string(),
        "" => {
            if leave_empty {
                return "".to_string();
            }

            warn!("Empty string provided in configuration option {option}, using default {default}");
            work_dir.join(default).display().to_string()
        }
        v => {
            let p = Path::new(v);
            if p.is_relative() {
                work_dir.join(p).display().to_string()
            } else {
                p.display().to_string()
            }
        }
    }
}

fn get_uuid(agent_uuid_config: &str) -> String {
    match agent_uuid_config {
        "hash_ek" => {
            info!("Using hashed EK as UUID");
            // DO NOT change this to something else. It is used later to set the correct value.
            "hash_ek".into()
        }
        "generate" => {
            let agent_uuid = Uuid::new_v4();
            info!("Generated a new UUID: {}", &agent_uuid);
            agent_uuid.to_string()
        }
        uuid_config => match Uuid::parse_str(uuid_config) {
            Ok(uuid_config) => uuid_config.to_string(),
            Err(_) => {
                warn!("Misformatted UUID: {}", &uuid_config);
                let agent_uuid = Uuid::new_v4();
                info!("Using generated UUID: {}", &agent_uuid);
                agent_uuid.to_string()
            }
        },
    }
}

// Unit Testing
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default() {
        let default = KeylimeConfig::default();

        let c = KeylimeConfig {
            agent: AgentConfig::default(),
        };

        let result = config_translate_keywords(&c);
        assert!(result.is_ok());
        let expected = result.unwrap(); //#[allow_ci]
        assert_eq!(expected, default);
    }

    #[test]
    fn test_hostname_support() {
        let default = AgentConfig::default();

        let modified = AgentConfig {
            ip: "localhost".to_string(),
            contact_ip: "contact.ip".to_string(),
            registrar_ip: "registrar.ip".to_string(),
            ..default
        };

        let c = KeylimeConfig { agent: modified };

        let result = config_translate_keywords(&c);
        assert!(result.is_ok());
        let result = result.unwrap(); //#[allow_ci]
        let resulting_ip = result.agent.ip;
        let resulting_contact_ip = result.agent.contact_ip;
        let resulting_registrar_ip = result.agent.registrar_ip;
        assert_eq!(resulting_ip, "localhost");
        assert_eq!(resulting_contact_ip, "contact.ip");
        assert_eq!(resulting_registrar_ip, "registrar.ip");
    }

    #[test]
    fn get_revocation_cert_path_default() {
        let test_config = KeylimeConfig::default();
        let revocation_cert_path = test_config.agent.revocation_cert.clone();
        let mut expected = Path::new(&test_config.agent.keylime_dir)
            .join("secure/unzipped")
            .join(DEFAULT_REVOCATION_CERT)
            .display()
            .to_string();
        assert_eq!(revocation_cert_path, expected);
    }

    #[test]
    fn get_revocation_cert_path_absolute() {
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                revocation_cert: "/test/cert.crt".to_string(),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
        let test_config = result.unwrap(); //#[allow_ci]
        let revocation_cert_path = test_config.agent.revocation_cert;
        let mut expected = Path::new("/test/cert.crt").display().to_string();
        assert_eq!(revocation_cert_path, expected);
    }

    #[test]
    fn get_revocation_cert_path_relative() {
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                revocation_cert: "cert.crt".to_string(),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
        let test_config = result.unwrap(); //#[allow_ci]
        let revocation_cert_path = test_config.agent.revocation_cert.clone();
        let mut expected = Path::new(&test_config.agent.keylime_dir)
            .join("cert.crt")
            .display()
            .to_string();
        assert_eq!(revocation_cert_path, expected);
    }

    #[test]
    fn get_revocation_notification_ip_empty() {
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                enable_revocation_notifications: true,
                revocation_notification_ip: "".to_string(),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        // Due to enable_revocation_notifications being set
        assert!(result.is_err());
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                enable_revocation_notifications: false,
                revocation_notification_ip: "".to_string(),
                ..Default::default()
            },
        };

        // Now unset enable_revocation_notifications and check that is allowed
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
        let test_config = result.unwrap(); //#[allow_ci]
        assert_eq!(
            test_config.agent.revocation_notification_ip,
            "".to_string()
        );
    }

    #[test]
    fn get_revocation_cert_empty() {
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                enable_revocation_notifications: true,
                revocation_cert: "".to_string(),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        // Due to enable_revocation_notifications being set
        assert!(result.is_err());
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                enable_revocation_notifications: false,
                revocation_cert: "".to_string(),
                ..Default::default()
            },
        };

        // Now unset enable_revocation_notifications and check that is allowed
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
    }

    #[test]
    fn get_revocation_actions_dir_empty() {
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                enable_revocation_notifications: true,
                revocation_actions_dir: "".to_string(),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        // Due to enable_revocation_notifications being set
        assert!(result.is_err());
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                enable_revocation_notifications: false,
                revocation_actions_dir: "".to_string(),
                ..Default::default()
            },
        };

        // Now unset enable_revocation_notifications and check that is allowed
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
    }

    #[test]
    fn test_translate_api_versions_latest_keyword() {
        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                api_versions: "latest".to_string(),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
        let config = result.unwrap(); //#[allow_ci]
        let version = config.agent.api_versions;
        let expected = SUPPORTED_API_VERSIONS
            .iter()
            .map(|e| e.to_string())
            .last()
            .unwrap(); //#[allow_ci]
        assert_eq!(version, expected);
    }

    #[test]
    fn test_translate_api_versions_default_keyword() {
        let default = KeylimeConfig::default();
        let result = config_translate_keywords(&default);
        assert!(result.is_ok());
        let config = result.unwrap(); //#[allow_ci]
        let version = config.agent.api_versions;
        let expected = SUPPORTED_API_VERSIONS
            .iter()
            .map(|e| e.to_string())
            .collect::<Vec<_>>()
            .join(", ");
        assert_eq!(version, expected);
    }

    #[test]
    fn test_translate_api_versions_old_supported() {
        let old = SUPPORTED_API_VERSIONS[0];

        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                api_versions: old.to_string(),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
        let config = result.unwrap(); //#[allow_ci]
        let version = config.agent.api_versions;
        assert_eq!(version, old);
    }

    #[test]
    fn test_translate_invalid_api_versions_filtered() {
        let old = SUPPORTED_API_VERSIONS[0];

        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                api_versions: format!("a.b, {old}, c.d"),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
        let config = result.unwrap(); //#[allow_ci]
        let version = config.agent.api_versions;
        assert_eq!(version, old);
    }

    #[test]
    fn test_translate_invalid_api_versions_fallback_default() {
        let old = SUPPORTED_API_VERSIONS;

        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                api_versions: "a.b, c.d".to_string(),
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
        let config = result.unwrap(); //#[allow_ci]
        let version = config.agent.api_versions;
        assert_eq!(version, old.join(", "));
    }

    #[test]
    fn test_translate_api_versions_sort() {
        let old = SUPPORTED_API_VERSIONS;
        let reversed = SUPPORTED_API_VERSIONS
            .iter()
            .rev()
            .copied()
            .collect::<Vec<_>>()
            .join(", ");

        let mut test_config = KeylimeConfig {
            agent: AgentConfig {
                api_versions: reversed,
                ..Default::default()
            },
        };
        let result = config_translate_keywords(&test_config);
        assert!(result.is_ok());
        let config = result.unwrap(); //#[allow_ci]
        let version = config.agent.api_versions;
        assert_eq!(version, old.join(", "));
    }

    #[test]
    fn test_get_uuid() {
        assert_eq!(get_uuid("hash_ek"), "hash_ek");
        let _ = Uuid::parse_str(&get_uuid("generate")).unwrap(); //#[allow_ci]
        assert_eq!(
            get_uuid("D432FBB3-D2F1-4A97-9EF7-75BD81C00000"),
            "d432fbb3-d2f1-4a97-9ef7-75bd81c00000"
        );
        assert_ne!(
            get_uuid("D432FBB3-D2F1-4A97-9EF7-75BD81C0000X"),
            "d432fbb3-d2f1-4a97-9ef7-75bd81c0000X"
        );
        let _ = Uuid::parse_str(&get_uuid(
            "D432FBB3-D2F1-4A97-9EF7-75BD81C0000X",
        ))
        .unwrap(); //#[allow_ci]
    }

    #[test]
    fn test_agent_config_as_source() {
        let default = AgentConfig::default();

        // Test that the AgentConfig can be used as a source for KeylimeConfig
        let config: KeylimeConfig = Config::builder()
            .add_source(default)
            .build()
            .unwrap() //#[allow_ci]
            .try_deserialize()
            .unwrap(); //#[allow_ci]
    }

    #[test]
    fn test_keylime_config_as_source() {
        let default = KeylimeConfig::default();

        // Test that the KeylimeConfig can be used as a source for KeylimeConfig
        let config: KeylimeConfig = Config::builder()
            .add_source(default)
            .build()
            .unwrap() //#[allow_ci]
            .try_deserialize()
            .unwrap(); //#[allow_ci]
    }

    #[test]
    fn test_env_config_as_source() {
        let default = KeylimeConfig::default();
        let env_config = EnvConfig::new().unwrap(); //#[allow_ci]

        // Test that the EnvConfig can be used as a source for KeylimeConfig
        let config: KeylimeConfig = Config::builder()
            .add_source(default)
            .add_source(env_config)
            .build()
            .unwrap() //#[allow_ci]
            .try_deserialize()
            .unwrap(); //#[allow_ci]
    }

    #[test]
    fn test_config_get_setting() {
        let env_config = config_get_setting().unwrap(); //#[allow_ci]
    }

    #[test]
    fn test_env_var() {
        let override_map: Map<&str, &str> = Map::from([
            ("KEYLIME_AGENT_AGENT_DATA_PATH", "override_agent_data_path"),
            ("KEYLIME_AGENT_ALLOW_PAYLOAD_REVOCATION_ACTIONS", "false"),
            ("KEYLIME_AGENT_API_VERSIONS", "latest"),
            ("KEYLIME_AGENT_CONTACT_IP", "override_contact_ip"),
            ("KEYLIME_AGENT_CONTACT_PORT", "9999"),
            (
                "KEYLIME_AGENT_DEC_PAYLOAD_FILE",
                "override_dec_payload_file",
            ),
            ("KEYLIME_AGENT_EK_HANDLE", "override_ek_handle"),
            ("KEYLIME_AGENT_ENABLE_AGENT_MTLS", "false"),
            ("KEYLIME_AGENT_ENABLE_IAK_IDEVID", "true"),
            ("KEYLIME_AGENT_ENABLE_INSECURE_PAYLOAD", "true"),
            ("KEYLIME_AGENT_ENABLE_REVOCATION_NOTIFICATIONS", "false"),
            ("KEYLIME_AGENT_ENC_KEYNAME", "override_enc_keyname"),
            ("KEYLIME_AGENT_EXTRACT_PAYLOAD_ZIP", "false"),
            ("KEYLIME_AGENT_IAK_CERT", "override_iak_cert"),
            ("KEYLIME_AGENT_IAK_HANDLE", "override_iak_handle"),
            (
                "KEYLIME_AGENT_IAK_IDEVID_ASYMMETRIC_ALG",
                "override_iak_idevid_asymmetric_alg",
            ),
            (
                "KEYLIME_AGENT_IAK_IDEVID_NAME_ALG",
                "override_iak_idevid_name_alg",
            ),
            (
                "KEYLIME_AGENT_IAK_IDEVID_TEMPLATE",
                "override_iak_idevid_template",
            ),
            ("KEYLIME_AGENT_IAK_PASSWORD", "override_iak_password"),
            ("KEYLIME_AGENT_IDEVID_CERT", "override_idevid_cert"),
            ("KEYLIME_AGENT_IDEVID_HANDLE", "override_idevid_handle"),
            ("KEYLIME_AGENT_IDEVID_PASSWORD", "override_idevid_password"),
            ("KEYLIME_AGENT_IMA_ML_PATH", "override_ima_ml_path"),
            ("KEYLIME_AGENT_IP", "override_ip"),
            ("KEYLIME_AGENT_KEYLIME_DIR", "override_keylime_dir"),
            (
                "KEYLIME_AGENT_MEASUREDBOOT_ML_PATH",
                "override_measuredboot_ml_path",
            ),
            ("KEYLIME_AGENT_PAYLOAD_SCRIPT", "override_payload_script"),
            ("KEYLIME_AGENT_PORT", "9999"),
            ("KEYLIME_AGENT_REGISTRAR_IP", "override_registrar_ip"),
            ("KEYLIME_AGENT_REGISTRAR_PORT", "9999"),
            (
                "KEYLIME_AGENT_REVOCATION_ACTIONS",
                "override_revocation_actions",
            ),
            (
                "KEYLIME_AGENT_REVOCATION_ACTIONS_DIR",
                "override_revocation_actions_dir",
            ),
            ("KEYLIME_AGENT_REVOCATION_CERT", "override_revocation_cert"),
            (
                "KEYLIME_AGENT_REVOCATION_NOTIFICATION_IP",
                "override_revocation_notification_ip",
            ),
            ("KEYLIME_AGENT_REVOCATION_NOTIFICATION_PORT", "9999"),
            ("KEYLIME_AGENT_RUN_AS", "override_run_as"),
            ("KEYLIME_AGENT_SECURE_SIZE", "override_secure_size"),
            ("KEYLIME_AGENT_SERVER_CERT", "override_server_cert"),
            ("KEYLIME_AGENT_SERVER_KEY", "override_server_key"),
            (
                "KEYLIME_AGENT_SERVER_KEY_PASSWORD",
                "override_server_key_password",
            ),
            (
                "KEYLIME_AGENT_TPM_ENCRYPTION_ALG",
                "override_tpm_encryption_alg",
            ),
            ("KEYLIME_AGENT_TPM_HASH_ALG", "override_tpm_hash_alg"),
            (
                "KEYLIME_AGENT_TPM_OWNERPASSWORD",
                "override_tpm_ownerpassword",
            ),
            ("KEYLIME_AGENT_TPM_SIGNING_ALG", "override_tpm_signing_alg"),
            (
                "KEYLIME_AGENT_TRUSTED_CLIENT_CA",
                "override_trusted_client_ca",
            ),
            ("KEYLIME_AGENT_UUID", "override_uuid"),
            ("KEYLIME_AGENT_VERSION", "override_version"),
        ]);

        // For possible variable
        for (c, v) in override_map.into_iter() {
            let default = KeylimeConfig::default();

            // Create a source emulating the environment with a variable set
            let env_source = Environment::with_prefix("KEYLIME_AGENT")
                .separator(".")
                .prefix_separator("_")
                .source(Some(Map::from([(c.into(), v.into())])));

            let env_config = EnvConfig {
                map: Map::from([(
                    "agent".to_string(),
                    Value::from(env_source.collect().unwrap()), //#[allow_ci]
                )]),
            };

            // Create the resulting configuration with a variable overriden
            let overriden: KeylimeConfig = Config::builder()
                .add_source(default)
                .add_source(env_config)
                .build()
                .unwrap() //#[allow_ci]
                .try_deserialize()
                .unwrap(); //#[allow_ci]

            let m = overriden.collect().unwrap(); //#[allow_ci]
            let internal = m.get("agent").unwrap(); //#[allow_ci]
            let obtained = internal.to_owned().into_table().unwrap(); //#[allow_ci]

            // Create the expected result by manually replacing the value
            let d = KeylimeConfig::default().collect().unwrap(); //#[allow_ci]
            let i = d.get("agent").unwrap(); //#[allow_ci]
            let mut expected = i.to_owned().into_table().unwrap(); //#[allow_ci]
            _ = expected.insert(
                c.to_lowercase()
                    .strip_prefix("keylime_agent_")
                    .unwrap() //#[allow_ci]
                    .into(),
                v.into(),
            );

            // Check that the obtained configuration matches the expected one
            for (i, e) in expected.iter() {
                let j = obtained.get(i).unwrap(); //#[allow_ci]
                assert!(
                    e.to_string() == j.to_string(),
                    "Option {} mismatch: expected == '{}', obtained == '{}'",
                    i,
                    e,
                    j
                );
            }
        }
    }

    #[test]
    fn test_config_get_file_path() {
        let workdir = Path::new("/workdir");
        let default = "default-file-name";

        let list_str = "[\"\", default, '', /absolute/path, relative/path, \"with spaces\", \"with,commas\", \"double_quotes\", 'single_quotes']";
        let list = parse_list(list_str).unwrap(); //#[allow_ci]

        assert_eq!(
            vec![
                "default",
                "/absolute/path",
                "relative/path",
                "\"with spaces\"",
                "\"with,commas\"",
                "\"double_quotes\"",
                "'single_quotes'"
            ],
            list
        );

        let translated: Vec<String> = list
            .iter()
            .map(|e| config_get_file_path("test", e, workdir, default, false))
            .collect();

        assert_eq!(
            vec![
                "/workdir/default-file-name",
                "/absolute/path",
                "/workdir/relative/path",
                "/workdir/\"with spaces\"",
                "/workdir/\"with,commas\"",
                "/workdir/\"double_quotes\"",
                "/workdir/'single_quotes'"
            ],
            translated
        );

        let translated =
            config_get_file_path("test", "", workdir, "default", true);
        assert_eq!("", translated);

        let translated =
            config_get_file_path("test", "", workdir, "default", false);
        assert_eq!("/workdir/default", translated);
    }
}
