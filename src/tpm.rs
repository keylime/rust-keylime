extern crate base64;
extern crate flate2;

use super::*;
use crypto::KeylimeCryptoError;
use flate2::write::ZlibEncoder;
use flate2::Compression;
use openssl::sha::Sha256;
use serde_json::Value;
use std::env;
use std::error::Error;
use std::fmt;
use std::fs::File;
use std::io::prelude::*;
use std::io::BufWriter;
use std::io::Read;
use std::process::Command;
use std::process::Output;
use std::str;
use std::thread;
use std::time::Duration;
use std::time::SystemTime;
use tempfile::NamedTempFile;

const MAX_TRY: usize = 10;
const RETRY_SLEEP: Duration = Duration::from_millis(50);
const TPM_IO_ERROR: i32 = 5;
const RETRY: usize = 4;

static EMPTYMASK: &'static str = "1";

/*
 * Input:
 *     Self activation flag
 *     New password given
 *
 * Return:
 *     ek key
 *     ek-cert
 *     aik key
 *     ek tpm
 *     aik-name
 *
 *  Initialize TPM with given new password and retrieve the original ek keys and
 *  aik key from TPM and store those manifest to the tpmdata.json for later TPM
 *  operations.
 */
fn tpm_init(
    self_activate: bool,
    config_pw: String,
) -> Result<(String, String, String, String, String), KeylimeTpmError> {
    emulator_warning();
    tpm_set_password(config_pw)?;
    tpm_create_ek(Some("sha256".into()))?;
    tpm_get_pub_ek()?;
    let ekcert = tpm_read_ekcert_nvram()?;
    set_tpm_metadata_content("ekcert", &ekcert);
    tpm_create_aik(
        self_activate,
        "rsa".into(),
        "sha256".into(),
        "rsassa".into(),
    )?;

    let ek = get_tpm_metadata_content("ek")?;
    let aik = get_tpm_metadata_content("aik")?;
    let ek_tpm = get_tpm_metadata_content("ek_tpm")?;
    let aik_name = get_tpm_metadata_content("aik_name")?;
    Ok((ek, ekcert.into(), aik, ek_tpm, aik_name))
}

/*
 *  Return:
 *      ek certificate to prove ek is generated by TPM
 *      Error if the retrieve process failed
 *
 *  Retrieve the certifcate of ek from nvram
 */
fn tpm_read_ekcert_nvram() -> Result<String, KeylimeTpmError> {
    let mut tf = NamedTempFile::new()?;
    let nvpath = temp_file_get_path(&tf)?;
    let (ret_out, _) = run("tpm2_nvlist".to_string(), None)?;
    let ret_out_value: Value = serde_yaml::from_str(&ret_out)?;
    if ret_out_value["0x1c00002"]["size"].is_null() {
        return Err(KeylimeTpmError::new_tpm_rust_error(
            "TPM nvlist failed.",
        ));
    }

    let ekcert_size = ret_out_value["0x1c00002"]["size"].clone();
    let (_, f_out) = run(
        format!("tpm2_nvread -x 0x1c00002 -s {} -f {}", ekcert_size, nvpath),
        Some(vec![nvpath]),
    )?;
    let ekcert = f_out.get(nvpath).ok_or_else(|| {
        KeylimeTpmError::new_tpm_rust_error(
            "failed to read nvram and retrieve ekcert.",
        )
    })?;
    Ok(base64::encode(ekcert))
}

/*
 *  Return:
 *     value from nvram
 *     Error if the process failed
 *
 *  Read the data stored in a Non-Volatile (NV)s index.
 */
fn tpm_read_key_nvram() -> Result<String, KeylimeTpmError> {
    let owner_pw = get_tpm_metadata_content("owner_pw")?;
    let (ret_out, _) = run(
        format!(
            "tpm2_nvread -x 0x1500018 -a 0x40000001 -s {} -P {}",
            common::BOOTSTRAP_KEY_SIZE,
            owner_pw
        ),
        None,
    )?;

    if ret_out.len() as i32 == common::BOOTSTRAP_KEY_SIZE {
        return Ok(ret_out.into());
    }
    Ok(String::new())
}

/*
 *  Input:
 *      key to write to nvram
 *  Return:
 *      Error if process failed
 *
 *  Write data to a Non-Volatile (NV) index.
 */
fn tpm_write_key_nvram(key: String) -> Result<(), KeylimeTpmError> {
    let owner_pw = get_tpm_metadata_content("owner_pw")?;
    let mut tf = NamedTempFile::new()?;
    tf.write_all(key.as_bytes())?;
    let attrs = "ownerread|policywrite|ownerwrite";
    let tf_path = temp_file_get_path(&tf)?;

    run(format!("tpm2_nvdefine -x 0x1500018 -a 0x40000001 -s {} -t \"{}\" -p {} -P {}", common::BOOTSTRAP_KEY_SIZE, attrs, owner_pw, owner_pw), None)?;
    run(
        format!(
            "tpm2_nvwrite -x 0x1500018 -a 0x40000001 -P {} {}",
            owner_pw, tf_path
        ),
        None,
    )?;
    Ok(())
}

/*
 *  Input:
 *      activation flag
 *      asymmetric algorithm
 *      hash algorithm
 *      sign algorithm
 *  Return:
 *      Error if the process failed.
 *
 *  Create a new aik key from TPM. Store the aik_name, aik_password,
 *  aik_public_key and aik_handle to tpmdata.json file.
 */
fn tpm_create_aik(
    activate: bool,
    asym_alg: String,
    hash_alg: String,
    sign_alg: String,
) -> Result<(), KeylimeTpmError> {
    let owner_pw = get_tpm_metadata_content("owner_pw")?;
    let aik = get_tpm_metadata_content("aik")?;
    let aik_name = get_tpm_metadata_content("aik_name")?;

    if !aik.is_empty() && !aik_name.is_empty() {
        let aik_handle = get_tpm_metadata_content("aik_handle")?;

        let (ret_out, _) =
            run("tpm2_getcap -c handles-persisitent".to_string(), None)?;
        let ret_out_map: Value = serde_yaml::from_str(&ret_out)?;
        if ret_out_map[&aik_handle].is_null() {
            run(
                format!(
                    "tpm2_evictcontrol -a o -c {} -P {}",
                    aik_handle, owner_pw
                ),
                None,
            )?;
        }
        set_tpm_metadata_content("aik", "")?;
        set_tpm_metadata_content("aik_name", "")?;
        set_tpm_metadata_content("aik_pw", "")?;
        set_tpm_metadata_content("aik_handle", "")?;
    }

    let ek_handle = get_tpm_metadata_content("ek_handle")?;
    if ek_handle.is_empty() {
        return Err(KeylimeTpmError::new_tpm_rust_error(
            "create ek failed. ek_handle is missing",
        ));
    }
    let aik_pw = random_password(20)?;

    let tf = NamedTempFile::new()?;
    let aik_pub_path = temp_file_get_path(&tf)?;
    let paths = vec![aik_pub_path];
    let (ret_out, f_out) = run(
        format!(
            "tpm2_createak -C {} -k - -G {} -D {} -s {} -p {} -f pem -e {} -P {} -o {}",
            hex::encode(ek_handle),
            asym_alg,
            hash_alg,
            sign_alg,
            aik_pub_path,
            owner_pw,
            aik_pw,
            owner_pw,
        ),
        Some(paths)
    )?;

    let ret_out_map: Value = serde_yaml::from_str(&ret_out)?;
    if ret_out_map["ak-persistent-handle"].is_null()
        || ret_out_map["loaded-key"]["name"].is_null()
    {
        return Err(KeylimeTpmError::new_tpm_rust_error(
            "TPM create aik failed to create aik.",
        ));
    }

    let pem = f_out.get(aik_pub_path).ok_or_else(|| {
        KeylimeTpmError::new_tpm_rust_error(
            "tpm2_createek failed with aik pub key missing.",
        )
    })?;

    let load_key_name = ret_out_map["load-key"]["name"]
        .as_str()
        .unwrap_or_else(|| "");
    let ak_persistent_handle = ret_out_map["ak-persistent-handle"]
        .as_str()
        .unwrap_or_else(|| "");

    if load_key_name == "" || ak_persistent_handle == "" {
        return Err(KeylimeTpmError::new_tpm_rust_error(
            "create_ek failed with attribute missing in the return output.",
        ));
    }

    set_tpm_metadata_content("aik", &pem)?;
    set_tpm_metadata_content("aik_pw", &aik_pw)?;
    set_tpm_metadata_content("aik_name", load_key_name)?;
    set_tpm_metadata_content("aik_handle", ak_persistent_handle)?;
    Ok(())
}

/*
 *  Input:
 *      new password to be set
 *
 *  Return:
 *      Error for unsuccessful password reset
 *
 *  Reset the password to the given new password, if new password is generate
 *  generate a 20 work size length random password from crypto libraray and
 *  use as new password. Store the final password to tpmdata.json file.
 */
fn tpm_set_password(config_pw: String) -> Result<(), KeylimeTpmError> {
    let owner_pw = match config_pw.as_str() {
        "generate" => random_password(20)?,
        _ => config_pw,
    };

    // Change authenticate, if the first fail, it will do it a second time.
    if let Err(e) = run(
        format!("tpm2_changeauth -o {} -e {}", owner_pw, owner_pw),
        None,
    ) {
        run(
            format!(
                "tpm2_changeauth -o {} -e {} -O {} -E {}",
                owner_pw, owner_pw, owner_pw, owner_pw
            ),
            None,
        )?;
    }
    set_tpm_metadata_content("owner_pw", &owner_pw)?;
    Ok(())
}

/*
 *  Input:
 *      hash algorithm for create new key
 *  Return:
 *      Error if create new key process failed.
 *
 *  Create a new ek key using TPM. Store the ek_handle, ek_password and
 *  ek_public_key to tpmdata.json file.
 */
fn tpm_create_ek(
    mut asym_alg: Option<String>,
) -> Result<(), KeylimeTpmError> {
    let ek_asym_alg = asym_alg.unwrap_or_else(|| String::from("encrypt"));
    let curr_handle = get_tpm_metadata_content("ek_handle")?;
    let mut owner_pw = get_tpm_metadata_content("owner_pw")?;

    if curr_handle.is_empty() && owner_pw.is_empty() {
        let (ret_out, _) =
            run(format!("tpm_getcap -c handles-persistent"), None)?;
        let v: Vec<&str> = ret_out.matches(&curr_handle).collect();
        if !v.is_empty() {
            run(
                format!(
                    "tpm2_evictcontrol -a o -c {} -P {}",
                    hex::encode(curr_handle),
                    owner_pw
                ),
                None,
            )?;
        }
    }

    if owner_pw.is_empty() {
        owner_pw = random_password(20)?;
        set_tpm_metadata_content("owner_pw", &owner_pw);
    }

    let ek_pw = random_password(20)?;
    let tf = NamedTempFile::new()?;
    let tf_path = temp_file_get_path(&tf)?;
    let paths: Vec<&str> = vec![tf_path];
    let (ret_out, f_out) = run(
        format!(
            "tpm2_createek -c -G {} -p {} -P {} -o {} -e {}",
            ek_asym_alg, tf_path, ek_pw, owner_pw, owner_pw
        ),
        Some(paths),
    )?;

    let ek_tpm = f_out.get(tf_path).ok_or_else(|| {
        KeylimeTpmError::new_tpm_rust_error(
            "Createek output to file content is missing",
        )
    })?;

    let ret_out_map: Value = serde_yaml::from_str(&ret_out)?;
    let persistent_handle = ret_out_map["persistent-handle"]
        .as_str()
        .unwrap_or_else(|| "");

    set_tpm_metadata_content("ek_handle", persistent_handle.into())?;
    set_tpm_metadata_content("ek_pw", &ek_pw);
    set_tpm_metadata_content("ek_tpm", &base64::encode(&ek_tpm));
    Ok(())
}

/*
 *  Return:
 *      Failed if retrieve public key process failed.
 *
 *  Retrieve the public key of ek key and store it in the tpmedata.json file.
 */
fn tpm_get_pub_ek() -> Result<(), KeylimeTpmError> {
    let ek_handle = get_tpm_metadata_content("ek_handle")?;
    let tf = NamedTempFile::new()?;
    let tf_path = temp_file_get_path(&tf)?;
    let paths = vec![tf_path];

    let (_, ret_file_map) = run(
        format!(
            "tpm2_readpublic -c {} -o {} -f pem",
            hex::encode(ek_handle),
            tf_path
        ),
        Some(paths),
    )?;

    let ek = ret_file_map.get(tf_path).ok_or_else(|| {
        KeylimeTpmError::new_tpm_rust_error(
            "tpm2_readpublic fail, ek key is missing is output file.",
        )
    })?;
    set_tpm_metadata_content("ek", &ek);
    Ok(())
}

/*
 *  Return;
 *      Error if the flush process failed
 *
 *  Retrieve all the persistent object and remove those object.
 */
fn flush_keys() -> Result<(), KeylimeTpmError> {
    let (ret_out, _) = run("tpm2_getcap -c handles-persistent".into(), None)?;
    let owner_pw = get_tpm_metadata_content("owner_pw")?;
    let ret_out_val: Value = serde_yaml::from_str(&ret_out)?;
    let ret_out_map: &Map<String, Value> =
        ret_out_val.as_object().ok_or_else(|| {
            KeylimeTpmError::new_tpm_rust_error("Output invalid.")
        })?;
    ret_out_map.iter().for_each(|(k, _)| {
        run(
            format!(
                "tpm2_evictcontrol -a o -c {} -P {}",
                hex::encode(k),
                owner_pw
            ),
            None,
        );
    });
    Ok(())
}

/*
 *  Input:
 *      pcr value to be extend
 *      hash for the extend
 *      hash algorithm for the extend
 *  Return:
 *      Error if the extend process failed
 *
 *  Extend the PCR 'pcrval' with the new hashvalue 'hashval' using 'hashalg'
 *  hashing algirthm.
 */
pub fn tpm_extend_pcr(
    pcrval: String,
    hashval: String,
    mut hashalg: String,
) -> Result<(), KeylimeTpmError> {
    if hashalg.is_empty() {
        hashalg = "sha256".into();
    }

    run(
        format!("tpm2_pcrextend {}:{}={}", pcrval, hashalg, hashval),
        None,
    )?;
    Ok(())
}

/*
 *  Input:
 *      pcr value to be read
 *      hash algorithm associate pcr
 *  Return:
 *      PCR data string
 *      KeylimeTpmError if it encounter error
 *
 *  Retrieve all the PCR values from TPM and retrieve the one that the
 *  intput requested.
 */
pub fn tpm_read_pcr(
    pcrval: String,
    hash_alg: Option<String>,
) -> Result<String, KeylimeTpmError> {
    let hash_alg_str = hash_alg.unwrap_or_else(|| String::from("sha256"));
    let (ret_out, _) = run(String::from("tpm2_pcrlist"), None)?;
    let ret_out_map: Value = serde_yaml::from_str(&ret_out)?;
    let alg_size: usize = match hash_alg_str.as_str() {
        "sha1" => 160,
        "sha256" => 256,
        "sha384" => 384,
        "sha512" => 512,
        _ => 0,
    };

    let value_num: i64 =
        ret_out_map[hash_alg_str][pcrval].as_i64().ok_or_else(|| {
            KeylimeTpmError::new_tpm_rust_error("Invalid pcr valur.")
        })?;
    let pcr_res = format!("{:0width$X}", value_num, width = alg_size / 4);
    Ok(pcr_res)
}

/*
 *  Input:
 *      keyblob, encrypted AIK key from registrar
 *  Return:
 *      decrypted key
 *      Error if the process fail
 *
 *  Decrypt the encrypted key with aik and ek to activate the credential of
 *  this TPM to the registrar.
 */
pub fn tpm_activate_identity(
    keyblob: String,
) -> Result<String, KeylimeTpmError> {
    let owner_pw = get_tpm_metadata_content("owner_pw")?;
    let aik_keyhandle = get_tpm_metadata_content("aik_handle")?;
    let ek_keyhandle = get_tpm_metadata_content("ek_handle")?;
    let aik_pw = get_tpm_metadata_content("aik_hanlde")?;
    let mut tf = NamedTempFile::new()?;
    tf.write_all(keyblob.as_bytes())?;
    let tf_path = temp_file_get_path(&tf)?;
    let secdir = secure_mount::mount()?;
    let tf_sec = NamedTempFile::new_in(secdir)?;
    let tf_sec_path = temp_file_get_path(&tf_sec)?;
    let (ret_out, f_out) = run(
        format!(
            "tpm2_activatecredential -c {} -C {} -f {} -o {} -P {} -E {}",
            hex::encode(aik_keyhandle),
            hex::encode(ek_keyhandle),
            tf_path,
            tf_sec_path,
            aik_pw,
            owner_pw
        ),
        Some(vec![tf_sec_path]),
    )?;

    let file_out = f_out.get(tf_sec_path).ok_or_else(|| {
        KeylimeTpmError::new_tpm_rust_error(
            "tpm_activate_identity failed with invalid file output.",
        )
    })?;

    Ok(base64::encode(file_out))
}

/*
 *  Input:
 *      content key in tpmdata
 *  Return:
 *      Value string
 *      KeylimeTpmError if the request content doesn't exist or reading file
 *      encounter error or content is not utf8 encoded.
 *
 *  Getting the tpm data struct and convert it to a json value object to
 *  retrive a particular value by the given key inside the tpm data.
 */
fn get_tpm_metadata_content(key: &str) -> Result<String, KeylimeTpmError> {
    let tpm_data = read_tpm_data()?;
    let remove: &[_] = &['"', ' ', '/'];
    tpm_data.get(key).map_or_else(
        || Ok(String::new()), // emty string if content not present
        |content| {
            content.as_str().map_or_else(
                || {
                    Err(KeylimeTpmError::new_tpm_rust_error(
                        "Failed to convert Value to stirng.",
                    ))
                },
                |s| Ok(s.to_string().trim_matches(remove).to_string()),
            )
        },
    )
}

/*
 *  Input:
 *       tpm data key
 *       tpm data value
 *  Return:
 *       success
 *       KeylimeTpmError
 *
 *  Set the corresponding tpm data key with new value and save the new content
 *  to tpmdata.json. This version remove global tpmdata variable. Read the
 *  file before write the content to the file.
 */
fn set_tpm_metadata_content(
    key: &str,
    value: &str,
) -> Result<(), KeylimeTpmError> {
    let mut tpm_data = read_tpm_data()?;
    match tpm_data.get_mut(key) {
        Some(ptr) => *ptr = json!(value),
        None => {
            return Err(KeylimeTpmError::new_tpm_rust_error(
                format!("Key: {} is missing in tpmdata.json", key).as_str(),
            ));
        }
    };

    write_tpm_data(tpm_data)?;
    Ok(())
}

/*
 *  Return:
 *      TPM data
 *      KeylimeTpmError
 *
 *  Read in tpmdata.json file and convert it to a pre-defined struct. Now its
 *  using the sample tpmdata.json in the crate root directory for testing. The
 *  format the same as the original python version. Result is returned to
 *  caller for error handling.
 */
fn read_tpm_data() -> Result<Value, KeylimeTpmError> {
    File::open("tpmdata.json")
        .and_then(|f| serde_json::from_reader(f).map_err(|e| e.into()))
        .map_err(|e| e.into())
}

/*
 *  Input: tpmdata in Value type
 *  Return:
 *      success
 *      KeylimeTpmError
 *
 *  Write the tpmdata to tpmdata.json file with result indicating execution
 *  result. Different implementation than the original python version, which
 *  changes the global variable tpmdata to local scope variable. Because it
 *  could read the data before write instead of using a static type to store
 *  it globally.
 */
fn write_tpm_data(data: Value) -> Result<(), KeylimeTpmError> {
    let mut buffer = BufWriter::new(File::create("tpmdata.json")?);
    let data_string = serde_json::to_string_pretty(&data)?;
    buffer.write(data_string.as_bytes())?;

    // Use flush to ensure all the intermediately buffered contents
    // reach their destination
    buffer.flush()?;
    Ok(())
}

/*
 *  Input:
 *      A temp file
 *  Return:
 *      The temp file path
 *      KeylimeTpmError
 */
fn temp_file_get_path<'a>(
    ref temp_file: &'a NamedTempFile,
) -> Result<&'a str, KeylimeTpmError> {
    temp_file.path().to_str().ok_or_else(|| {
        KeylimeTpmError::new_tpm_rust_error("Can't retrieve temp file path.")
    })
}

/*
 * Return:
 *     true for vtpm/false otherwise
 *
 * If tpm is a tpm elumator, return true, other wise return false
 */
pub fn is_vtpm() -> bool {
    false
}

/*
 *  Return;
 *      true for software tpm false otherwise
 *
 *  Software TPM information is based on the return value of the get
 *  manufacturer function. Even the return value is error, still return
 *  false for not using a simulator. Because simulator must contains a "SW"
 *  in its manufacturer information list.
 */
pub fn is_software_tpm() -> bool {
    match tpm_get_manufacturer() {
        Ok(data) => data == "SW",
        Err(e) => {
            warn!("Fail to get tpm manufacturer information. Error {}.", e);
            false
        }
    }
}

/*
 *  Return:
 *      manufacture information
 *      KeylimeTpmError
 *
 *  getting the tpm manufacturer information
 *  is_vtpm helper method
 */
fn tpm_get_manufacturer() -> Result<String, KeylimeTpmError> {
    let (return_output, _) =
        run("tpm2_getcap -c properties-fixed".to_string(), None)?;
    let ret_to_json: Value = serde_json::from_str(&return_output)?;
    if let None = ret_to_json.get("TPM2_PT_VENDOR_STRING_1") {
        return Err(KeylimeTpmError::new_tpm_rust_error(
            "TPM manufacture information is missing.",
        ));
    }
    Ok(ret_to_json["TPM2_PT_VENDOR_STRING_1"]["value"].to_string())
}

/*
 *  Input:
 *      nonce string
 *      data that needs to be pass to the pcr
 *      pcrmask
 *
 *  Output:
 *      quote from tpm pcr
 *      KeylimeTpmError
 *
 *  Getting quote form tpm, same implementation as the original python version.
 *  Use SHA256 as default hash algorithm.
 */
pub fn create_quote(
    nonce: String,
    data: String,
    mut pcrmask: String,
) -> Result<String, KeylimeTpmError> {
    let hash_alg = "SHA256";
    let quote_tf = NamedTempFile::new()?;
    let sign_tf = NamedTempFile::new()?;
    let pcr_tf = NamedTempFile::new()?;
    let key_handle = get_tpm_metadata_content("aik_handle")?;
    let aik_pw = get_tpm_metadata_content("aik_pw")?;
    if pcrmask == "".to_string() {
        pcrmask = EMPTYMASK.to_string();
    }
    let pcr_list = pcr_mask_to_list(pcrmask, hash_alg.to_string())?;

    if !(data.is_empty()) {
        run(format!("tpm2_pcrreset {}", common::TPM_DATA_PCR), None)?;
        let mut hash_data = Sha256::new();
        hash_data.update(data.as_bytes());
        let digest_data = hash_data.finish();
        run(
            format!(
                "tpm2_pcrextend {}:{}={}",
                common::TPM_DATA_PCR,
                hash_alg,
                hex::encode(digest_data)
            ),
            None,
        )?;
    }

    let quote_path = temp_file_get_path(&quote_tf)?;
    let sign_path = temp_file_get_path(&sign_tf)?;
    let pcr_path = temp_file_get_path(&pcr_tf)?;

    let paths = vec![quote_path, sign_path, pcr_path];

    let (_, quotes) = run(
        format!(
            "tpm2_deluxequote -C {} -L {}:{} -q {} -m {} -s {} -p {} -G {} -P {}",
            hex::encode(key_handle),
            hash_alg,
            pcr_list,
            hex::encode(nonce),
            quote_path,
            sign_path,
            pcr_path,
            hash_alg,
            aik_pw,
        ),
        Some(paths)
    )?;

    let mut quote_list = Vec::new();
    for val in quotes.values() {
        quote_list.push(base64_zlib_encode(val.to_string())?);
    }

    Ok(quote_list.as_slice().join(":"))
}

/*
 *  Deep quote is in progress
 */
pub fn create_deep_quote(
    nonce: String,
    data: String,
    pcrmask: String,
    vpcrmask: String,
) -> Result<String, KeylimeTpmError> {
    Err(KeylimeTpmError::new_tpm_rust_error(
        "Deep quote in progress.",
    ))
}

/*
 *  Warning for not using physical TPM
 */
fn emulator_warning() {
    if is_software_tpm() {
        warn!(
            "INSECURE: Keylime is using a software TPM emulator rather than a
              real hardware TPM."
        );
        warn!(
            "INSECURE: The security of Keylime is NOT linked to a hardware
              root of trust."
        );
        warn!(
            "INSECURE: Only use Keylime in this mode for testing or debugging
              purposes."
        );
    }
}

/*
 *  Input:
 *      password length
 *  Return:
 *      password string with given length
 *
 *  Generate a new random byte from crypto library and format with a string
 *  as the new random password.
 */
fn random_password(length: usize) -> Result<String, KeylimeTpmError> {
    let rand_byte = crypto::generate_random_byte(&length)?;
    let alphabet: Vec<char> =
        "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGIJKLMNOPQRSTUVWXYZ"
            .chars()
            .collect();

    let mut password = Vec::new();
    for i in rand_byte.as_slice() {
        password.push(alphabet[*i as usize % alphabet.len()]);
    }
    let password_str: String = password.iter().collect();
    Ok(password_str)
}

/*
 *  Input: string to be encoded
 *  Output:
 *      encoded string output
 *      KeylimeTpmError
 *
 *  Use zlib to compression the input and encoded with base64 encoding
 *  method
 *
 *  It doesn't given the same hex output as python but python is able to
 *  decode the hex output and give back the original text message. No able
 *  to test with identical python function output string.
 */
fn base64_zlib_encode(data: String) -> Result<String, KeylimeTpmError> {
    let mut encoder = ZlibEncoder::new(Vec::new(), Compression::default());
    encoder.write_all(data.as_bytes())?;
    let compressed_bytes = encoder.finish()?;
    Ok(base64::encode(&compressed_bytes))
}

/*
 *  Input: ima mask
 *         ima pcr
 *  Output: match result
 *
 *  If ima_mask match ima_pcr return true, otherwise, return false. Same as
 *  original python version.
 */
pub fn check_mask(
    ima_mask: &str,
    ima_pcr: i32,
) -> Result<bool, KeylimeTpmError> {
    if ima_mask.is_empty() {
        return Ok(false);
    }
    let ima_mask_int: i32 = ima_mask.parse()?;
    Ok((1 << ima_pcr) & ima_mask_int != 0)
}

pub fn pcr_mask_to_list(
    mask: String,
    hash_alg: String,
) -> Result<String, KeylimeTpmError> {
    let mut pcr_list = Vec::new();
    let mut ima_appended = String::new();

    for pcr in 0..24 {
        let check_result = check_mask(&mask, pcr)?;
        if check_result {
            if hash_alg == "SHA1" && pcr == 10 {
                ima_appended.push_str(format!("+sha1:{}", pcr).as_str());
            } else {
                pcr_list.push(pcr.to_string());
            }
        }
    }
    let mut result: String = pcr_list.as_slice().join(",");
    result.push_str(&ima_appended);
    Ok(result)
}

/*
 *  Input: quote string
 *  Output: deep quote check result boolean
 *
 *  Check the quote string, if it is deep quote string, return true, otherwise,
 *  return false. Same as the original python version.
 */
pub fn is_deep_quote(quote: String) -> bool {
    match &quote[0..1] {
        "d" => true,
        "r" => false,
        _ => {
            warn!("Invalid quote type {}", quote);
            false
        }
    }
}

/*
 *  Input: file name
 *  Return: the content of the file int Result<>
 *
 *  run method helper method
 *  read in the file and  return the content of the file into a Result enum
 */
fn read_file_output_path(output_path: String) -> std::io::Result<String> {
    let mut file = File::open(output_path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

/*
 *  Input:
 *      command: command to be executed
 *      output_path: file output location
 *  return:
 *      execution return output String and file output List Map
 *      KeylimeTpmError
 *
 *  Set up execution envrionment to execute tpm command through shell commands
 *  and return the execution result in a tuple. Based on the latest update of
 *  python keylime this function implement the functionality of cmd_exec
 *  script in the python keylime repo. RaiseOnError, return code and lock are
 *  dropped due to different error handling in Rust. Returned output string are
 *  preprocessed to before returning for code efficient.
 */
pub fn run(
    command: String,
    output_path: Option<Vec<&str>>,
) -> Result<(String, HashMap<String, String>), KeylimeTpmError> {
    // tokenize input command
    let words: Vec<&str> = command.split(" ").collect();
    let mut number_tries = 0;
    let args = &words[1..words.len()];
    let cmd = &words[0];

    // setup environment variable
    let mut env_vars: HashMap<String, String> = HashMap::new();
    for (key, value) in env::vars() {
        env_vars.insert(key.to_string(), value.to_string());
    }
    let lib_path = env_vars
        .get("LD_LIBRARY_PATH")
        .map_or_else(|| String::new(), |v| v.clone());
    env_vars.insert(
        "LD_LIBRARY_PATH".to_string(),
        format!("{}:{}", lib_path, common::TPM_LIBS_PATH),
    );
    env_vars.insert(
        "TPM2TOOLS_TCTI".to_string(),
        "tabrmd:bus_name=com.intel.tss2.Tabrmd".to_string(),
    );
    // env_vars.insert("TPM2TOOLS_TCTI".to_string(), "mssim:port=2321".to_string());
    // env_vars.insert("TPM2TOOLS_TCTI".to_string(), "device:/dev/tpm0".to_string());

    match env_vars.get_mut("PATH") {
        Some(v) => v.push_str(common::TPM_TOOLS_PATH),
        None => {
            return Err(KeylimeTpmError::new_tpm_rust_error(
                "PATH envrionment variable dosen't exist.",
            ));
        }
    }

    // main loop
    let mut output: Output;
    'exec: loop {
        // Start time stamp
        let t0 = SystemTime::now();

        output = Command::new(&cmd).args(args).envs(&env_vars).output()?;

        // measure execution time
        let t_diff = t0.duration_since(t0)?;
        info!("Time cost: {}", t_diff.as_secs());

        // assume the system is linux
        println!("number tries: {:?}", number_tries);

        match output.status.code() {
            Some(TPM_IO_ERROR) => {
                number_tries += 1;
                if number_tries >= MAX_TRY {
                    return Err(KeylimeTpmError::new_tpm_error(
                        TPM_IO_ERROR,
                        "TPM appears to be in use by another application. 
                         Keylime is incompatible with other TPM TSS 
                         applications like trousers/tpm-tools. Please 
                         uninstall or disable.",
                    ));
                }

                info!(
                    "Failed to call TPM {}/{} times, trying again in {} secs.",
                    number_tries,
                    MAX_TRY,
                    RETRY,
                );

                thread::sleep(RETRY_SLEEP);
            }

            _ => break 'exec,
        }
    }

    let return_output = String::from_utf8(output.stdout)?;
    match output.status.code() {
        None => {
            return Err(KeylimeTpmError::new_tpm_rust_error(
                "Execution return code is None.",
            ));
        }
        Some(0) => info!("Successfully executed TPM command."),
        Some(c) => {
            return Err(KeylimeTpmError::new_tpm_error(
                c,
                format!(
                    "Command: {} returned {}, output {}",
                    command, c, return_output,
                )
                .as_str(),
            ));
        }
    }

    let mut file_output: HashMap<String, String> = HashMap::new();
    if let Some(paths) = output_path {
        for p in paths {
            file_output
                .insert(p.into(), read_file_output_path(p.to_string())?);
        }
    }
    Ok((return_output, file_output))
}

/*
 * Custom Error type for tpm execution error. It contains both error from the
 * TPM command execution result or error cause by rust function. Potential
 * rust error are map to this error by implemented From<> trait.
 */
#[derive(Debug)]
pub enum KeylimeTpmError {
    TpmRustError { details: String },
    TpmError { code: i32, details: String },
}

impl KeylimeTpmError {
    fn new_tpm_error(err_code: i32, err_msg: &str) -> KeylimeTpmError {
        KeylimeTpmError::TpmError {
            code: err_code,
            details: err_msg.to_string(),
        }
    }

    fn new_tpm_rust_error(err_msg: &str) -> KeylimeTpmError {
        KeylimeTpmError::TpmRustError {
            details: err_msg.to_string(),
        }
    }
}

impl Error for KeylimeTpmError {
    fn description(&self) -> &str {
        match &self {
            KeylimeTpmError::TpmError {
                ref details,
                code: _,
            } => details,
            KeylimeTpmError::TpmRustError { ref details } => details,
        }
    }
}

impl fmt::Display for KeylimeTpmError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            KeylimeTpmError::TpmError {
                ref code,
                ref details,
            } => write!(
                f,
                "Execute TPM command failed with Error Code: [{}] and 
                Error Message [{}].",
                code, details,
            ),
            KeylimeTpmError::TpmRustError { ref details } => write!(
                f,
                "Error occur in TPM rust interface with message [{}].",
                details,
            ),
        }
    }
}

impl From<std::io::Error> for KeylimeTpmError {
    fn from(e: std::io::Error) -> KeylimeTpmError {
        KeylimeTpmError::new_tpm_rust_error(e.description())
    }
}

impl From<std::time::SystemTimeError> for KeylimeTpmError {
    fn from(e: std::time::SystemTimeError) -> KeylimeTpmError {
        KeylimeTpmError::new_tpm_rust_error(e.description())
    }
}

impl From<std::string::FromUtf8Error> for KeylimeTpmError {
    fn from(e: std::string::FromUtf8Error) -> KeylimeTpmError {
        KeylimeTpmError::new_tpm_rust_error(e.description())
    }
}

impl From<serde_json::error::Error> for KeylimeTpmError {
    fn from(e: serde_json::error::Error) -> KeylimeTpmError {
        KeylimeTpmError::new_tpm_rust_error(e.description())
    }
}

impl From<std::num::ParseIntError> for KeylimeTpmError {
    fn from(e: std::num::ParseIntError) -> KeylimeTpmError {
        KeylimeTpmError::new_tpm_rust_error(e.description())
    }
}

impl From<serde_yaml::Error> for KeylimeTpmError {
    fn from(e: serde_yaml::Error) -> KeylimeTpmError {
        KeylimeTpmError::new_tpm_rust_error(e.description())
    }
}

impl From<Box<String>> for KeylimeTpmError {
    fn from(e: Box<String>) -> KeylimeTpmError {
        KeylimeTpmError::new_tpm_rust_error(&e)
    }
}

/*
 * These test are for Centos and tpm4720 elmulator install environment. It
 * test tpm command before execution.
 */
#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;
    use std::fs;

    #[test]
    fn test_read_file_output_path() {
        assert_eq!(
            read_file_output_path("test_input.txt".to_string()).unwrap(),
            "Hello World!\n"
        );
    }

    #[test]
    fn test_get_temp_file_path() {
        let tmp_f = NamedTempFile::new().unwrap();
        assert!(temp_file_get_path(&tmp_f).is_ok());
    }

    #[test]
    fn test_is_deep_quote() {
        assert_eq!(is_deep_quote(String::from("dqewrtypuo")), true);
    }

    #[test]
    fn test_is_vtpm() {
        // placeholder vtpm working in progress
        assert!(true);
    }

    #[test]
    fn test_tpm_get_manufacturer() {
        match command_exist("tpm2_getcap") {
            true => {
                assert!(tpm_initialize().is_ok());
                assert!(tpm_get_manufacturer().is_ok());
            }
            false => assert!(true),
        }
    }

    #[test]
    fn test_zlib_encoding() {
        let bytes = base64::decode("eJzLTq3MycxN1S0qLS4BAB/wBOw=").unwrap();
        let mut z = flate2::read::ZlibDecoder::new(&bytes[..]);
        let mut s = String::new();
        z.read_to_string(&mut s).unwrap();
        assert_eq!(String::from("keylime-rust"), s);
    }

    #[test]
    fn test_run_command() {
        match command_exist("tpm2_getrandom") {
            true => {
                assert!(tpm_initialize().is_ok());
                let command = "getrandom -size 8 -out foo.out".to_string();
                run(command, None);
                let p = Path::new("foo.out");
                assert_eq!(p.exists(), true);
                fs::remove_file("foo.out").unwrap();
            }
            false => assert!(true),
        }
    }

    fn tpm_initialize() -> Result<(), KeylimeTpmError> {
        run("tpm2_startup -c".to_string(), None).map(|x| ())
    }

    #[test]
    fn test_get_tpm_metadata_1() {
        assert!(set_tpmdata_test().is_ok());

        // using test tpmdata.json content must present, system won't panic
        let remove: &[_] = &['"', ' ', '/'];
        let password = get_tpm_metadata_content("aik_handle")
            .expect("Failed to get aik_handle.");
        assert_eq!(password.trim_matches(remove), String::from("FB1F19E0"));
    }

    #[test]
    fn test_get_tpm_metadata_2() {
        assert!(set_tpmdata_test().is_ok());

        // foo is not a key in tpmdata, this call should fail
        assert_eq!(get_tpm_metadata_content("foo").unwrap(), String::new());
    }

    #[test]
    fn test_write_tpm_metadata() {
        assert!(set_tpmdata_test().is_ok());
        set_tpm_metadata_content("owner_pw", "hello")
            .expect("Failed to set owner_pw.");

        // using test tpmdata.json content must present, system won't panic
        let remove: &[_] = &['"', ' ', '/'];
        let password = get_tpm_metadata_content("owner_pw")
            .expect("Failed to get owner_pw.");
        assert_eq!(password.trim_matches(remove), String::from("hello"));
    }

    #[test]
    fn test_random_password() {
        let pw = random_password(20).unwrap();
        assert_eq!(pw.len(), 20);
    }

    /*
     * Input: command name
     * Output: checkout command result
     *
     * Look for the command in path, if command is there return true, if
     * command is not exist return false.
     */
    fn command_exist(command: &str) -> bool {
        if let Ok(path) = env::var("PATH") {
            for pp in path.split(":") {
                let command_path = format!("{}/{}", pp, command);
                if fs::metadata(command_path).is_ok() {
                    return true;
                }
            }
        }
        false
    }

    /*
     * copy tpmdata_test.json file to tpmdata.json for testing
     */
    fn set_tpmdata_test() -> Result<(), Box<Error>> {
        let file = File::open("tpmdata_test.json")?;
        let data: Value = serde_json::from_reader(file)?;
        let mut buffer = BufWriter::new(File::create("tpmdata.json")?);
        let data_string = serde_json::to_string_pretty(&data)?;
        buffer.write(data_string.as_bytes())?;
        buffer.flush()?;
        Ok(())
    }
}
